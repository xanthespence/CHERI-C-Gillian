#internal

proc i__cheri_address_get(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: ret := {{ l-nth(cap, 0i), l-nth(cap, 1i) }};
      return;
 fal: fail[invalidcap]("i__cheri_address_get(cap) : cap is not a capability. ")
};

proc i__cheri_base_get(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: ret := {{ l-nth(cap, 0i), l-nth(cap, 2i) }};
      return;
 fal: fail[invalidcap]("i__cheri_base_get(cap) : cap is not a capability. ")
};

proc i__cheri_length_get(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: ret := "i__unops_cast"("uint64", {{ "uint64", l-nth(cap, 3i) }});
      return;
 fal: fail[invalidcap]("i__cheri_length_get(cap) : cap is not a capability. ")
};

proc i__cheri_offset_get(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: ret := "i__unops_cast"("uint64", {{ "uint64", l-nth(cap, 1i) }});
      return;
 fal: fail[invalidcap]("i__cheri_offset_get(cap) : cap is not a capability. ")
};

proc i__cheri_tag_get(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] yes nop;
 yes: goto [ l-nth(cap, 10i) ] tru fal;
 tru: ret := {{ "int32", 1i }};
      return;
 fal: ret := {{ "int32", 0i }};
      return;
 nop: fail[invalidcap]("i__cheri_tag_get(cap) : cap is not a capability. ")
};

proc i__cheri_address_set(cap, addr) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: goto [ l-nth(cap, 0i) = l-nth(addr, 0i) ] asd wdr;
 asd: ret := {{ l-nth(cap, 0i), l-nth(addr, 1i), l-nth(cap, 2i), l-nth(cap, 3i),
                l-nth(cap, 4i), l-nth(cap, 5i), l-nth(cap, 6i), l-nth(cap, 7i),
                l-nth(cap, 8i), l-nth(cap, 9i), l-nth(cap, 10i), l-nth(cap, 11i) }};
      return;
 wdr: fail[invalidblockid]("i__cheri_address_set(cap, addr) : different block values.");
 fal: fail[invalidcap]("i__cheri_address_set(cap, addr) : cap is not a capability.")
};

proc i__cheri_tag_clear(cap) {
      tmp := "i__is_cap"(cap);
      goto [ tmp ] tru fal;
 tru: ret := {{ l-nth(cap, 0i), l-nth(cap, 1i), l-nth(cap, 2i), l-nth(cap, 3i), 
                l-nth(cap, 4i), l-nth(cap, 5i), l-nth(cap, 6i), l-nth(cap, 7i), 
                l-nth(cap, 8i), l-nth(cap, 9i), false, l-nth(cap, 11i) }};
      return;
 fal: fail[invalidcap]("i__cheri_tag_clear(cap) : cap is not a capability.")
};

(* builtin functions are abstractions of the original implementation *)

(** Notes                   #
  * -------------------------
  * LOAD                    0
  * STORE                   1
  * LOAD_CAPABILITY         2
  * STORE_CAPABILITY        3
  * STORE_LOCAL_CAPABILITY  4
  * GLOBAL                  5 *)

proc i__builtin_cheri_perms_get(cap, val) {
      nval := {{ "int32", l-nth(val, 1i) i+ 4i }};
      goto [ l-nth(nval, 1i) i> 9i ] fai suc;
 suc: ret := "i__value_of_bool"(l-nth(cap, l-nth(nval, 1i)));
      return;
 fai: fail[invalid]("permission parameter invalid! Use constants...")
};
