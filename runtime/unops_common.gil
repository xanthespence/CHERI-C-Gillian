#internal

proc i__unops_negb (val) {
       goto [ l-nth(val, 1i) = 0i ] ctn utd;
  ctn: ret := {{ "int32", 1i }};
       return;
  utd: ret := {{ "int32", 0i }};
       return
};

(** casting involves three processes:
  * 1. Casting capabilities: "i__unops_cast"(ni, cap);
  *    Casting capabilities changes the cap "offsiz" value
  * 2. Casting primitive values: "i__unops_cast"("type", value)
  *    Casting values internally calls [cast_val].
  * 3. Casting anything to _Bool: "i__unops_cast"("_Bool", value);
  *    needed for assert(a);
  *)
proc i__unops_cast (typ, val) {
       (* case 1 *)
       goto [ typeOf(typ) = Int ] nct tptr;
 tptr: goto [ typ = "_Bool" ] bct nptr;
  bct: asdf := "i__is_cap"(val);
       goto [ asdf ] t1 t2;
       (* case 3 *)
   t1: tmp := [NULL]();
       ret := "i__binops_cmp_neq"(val, tmp);
       return;
   t2: ret := "i__binops_cmp_neq"(val, {{ l-nth(val, 0i), 0i }});
       return;
  nct: ptrt := "i__is_cap"(val);
       goto [ ptrt ] pend feil;
 pend: ret := {{ l-nth(val, 0i), l-nth(val, 1i), l-nth(val, 2i), l-nth(val, 3i), 
                 l-nth(val, 4i), l-nth(val, 5i), l-nth(val, 6i), l-nth(val, 7i), 
                 l-nth(val, 8i), l-nth(val, 9i), l-nth(val, 10i), typ }};
       return;
       (* case 2 *)
 nptr: goto [ typeOf(typ) = Str ] tval feil;
 tval: ret := [cast_val](typ, val);
       return;
 feil: fail[comparison]("Cast not supported or invalid arg")
};

proc i__is_cap (cap) {
       goto [ l-len(cap) = 12i ] nxt utd;
  nxt: goto [( (typeOf(l-nth(cap, 0i)) = Obj) and
               (typeOf(l-nth(cap, 1i)) = Int) and
               (typeOf(l-nth(cap, 2i)) = Int) and
               (typeOf(l-nth(cap, 3i)) = Int) and
               (typeOf(l-nth(cap, 4i)) = Bool) and
               (typeOf(l-nth(cap, 5i)) = Bool) and
               (typeOf(l-nth(cap, 6i)) = Bool) and
               (typeOf(l-nth(cap, 7i)) = Bool) and
               (typeOf(l-nth(cap, 8i)) = Bool) and
               (typeOf(l-nth(cap, 9i)) = Bool) and
               (typeOf(l-nth(cap, 10i)) = Bool) and
               (typeOf(l-nth(cap, 11i)) = Int) )] ctn utd;
  ctn: ret := true;
       return;
  utd: ret := false;
       return
};

